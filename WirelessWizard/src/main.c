/**
 * \file main.c
 *
 * Created: 25.02.2015 12:56:53
 * Author: alex
 *
 * \brief  Main file of Wireless Project generated by Project Wizard
 *
 * Copyright (c) 2014 Atmel Corporation. All rights reserved.
 *
 * \asf_license_start
 *
 * \page License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name of Atmel may not be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * 4. This software may only be redistributed and used in connection with an
 *    Atmel microcontroller product.
 *
 * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \asf_license_stop
 */

/**
 * \page license License
 * Copyright(c) 2014, Atmel Corporation All rights reserved.
 *
 * Licensed under Atmel's Limited License Agreement --> EULA.txt
 */

/* === INCLUDES ============================================================ */

#include "tal.h"
#include "wireless_api.h"

#include <tal_internal.h>
#include <tal_pib.h>

/* === PROTOTYPES ====================================================== */

/**
 * \brief Application task
 */
static void app_task(void);

void prcm_usb_data_received(udd_ep_status_t status,
	iram_size_t nb_transfered, udd_ep_id_t ep);


/* === IMPLEMENTATION ====================================================== */

/**
 * \brief Main function of the application
 */
int main(void)
{	
	/* Initialize the Wireless Module */
	wireless_init();    
	
	/*The Modules selected in the wizard are initialized here */
	modules_init();

	udc_attach(); /* attach to USB bus at end of initialization */

	while (1)
	{
		/* These methods are called to perform the default tasks of the MAC Stack */
		pal_task();
		tal_task();
		/* Custom (User) tasks are performed here. */
		app_task();
	}
}

queue_t	qfWPANtUSB;

/**
 * \brief USB data receive callback
 */
uint8_t usb_out_buff[128];
void prcm_usb_data_received(udd_ep_status_t status,
iram_size_t nb_transfered, udd_ep_id_t ep)
{
	buffer_t *bmm_buff;

	if (status == UDD_EP_TRANSFER_OK) {
		uint8_t msg_size = usb_out_buff[0];
		bmm_buff = bmm_buffer_alloc(msg_size);
		if(bmm_buff != NULL) {
			frame_info_t *frame;

			frame = malloc(sizeof(frame_info_t));
			if(frame != NULL) {
				/* Frame and buffer allocated */
				memcpy(bmm_buff->body,usb_out_buff, nb_transfered); // FCS not received from host, but counted in length
				frame->mpdu = bmm_buff->body;
				frame->buffer_header = bmm_buff;
				if (wdev->wpan_active) { /* connected and stated */
					if (TAL_BUSY == tal_tx_frame(frame, wdev->csma_mode,
							wdev->max_frame_retries == 0 ? false : true) ) {
						/* TODO: Handle frame prepared, but TAL busy */
						/* This time clean and restart transfer */
						free(frame);
						bmm_buffer_free(bmm_buff);
						udi_vendor_bulk_out_run(usb_out_buff, sizeof(usb_out_buff),&prcm_usb_data_received);	
					};
				} else { /* device connected, but _NOT_ started */
					free(frame);
					bmm_buffer_free(bmm_buff);
					udi_vendor_bulk_out_run(usb_out_buff, sizeof(usb_out_buff),&prcm_usb_data_received);					
				};
			} else {
				/* TODO: Handle transfer OK, but no memory for frame */
				/* free buffer and restart transfer */
				bmm_buffer_free(bmm_buff);
				udi_vendor_bulk_out_run(usb_out_buff, sizeof(usb_out_buff),&prcm_usb_data_received);
			};
		} else {
			/* TODO Handle transfer OK, but no memory for USB input buffer */
			/* This time - restart transfer */
			udi_vendor_bulk_out_run(usb_out_buff, sizeof(usb_out_buff),&prcm_usb_data_received);
		}
	} else {
		/* TODO handle usb input fail transfer */
		/* This time - restart transfer */
		udi_vendor_bulk_out_run(usb_out_buff, sizeof(usb_out_buff),&prcm_usb_data_received);
	}
}

/**
 * \brief Application task
 */
uint8_t receive_psdu[128 + 1];
 void app_task(void)
{
	buffer_t *wpan_to_usb;
	
	wpan_to_usb = qmm_queue_remove(&qfWPANtUSB, NULL);
	if(wpan_to_usb != NULL) {
		uint8_t usb_msg_size = wpan_to_usb->body[0] + 3; /* Frame + LQI */
		
		memcpy(receive_psdu, wpan_to_usb->body, usb_msg_size);
		if (wdev->wpan_active) /* only if host ready for data */
			/* TODO: This time _NOT_ handle error on USB data send to host */
			udi_vendor_bulk_in_run(receive_psdu, usb_msg_size, NULL);
		bmm_buffer_free(wpan_to_usb);
	}
}

/**
 *
 * \brief This method (callback) is called when a frame has been transmitted by the transceiver
 * \param status  Status of frame transmission i.e MAC_SUCCESS,MAC_NO_ACK,CHANNEL_ACCESS_FAILURE etc
 * \param frame pointer to the transmitted frame
 */
void tal_tx_frame_done_cb(retval_t status, frame_info_t *frame)
{
	/*Perform application tasks when a frame is transmitted here*/
	
	// Free-up the buffer which was used for transmission once the frame is extracted.
	bmm_buffer_free(frame->buffer_header);
	// Free-up allocated frame_info_t* structure
	free(frame);
	// restart USB packet receive
	udi_vendor_bulk_out_run(usb_out_buff, sizeof(usb_out_buff),&prcm_usb_data_received);
}

/**
 *
 * \brief This method (callback) is called when a frame is received by the transceiver
 * \param frame pointer to the received frame
 *
 */
void tal_rx_frame_cb(frame_info_t *frame)
{
	buffer_t *rcv_frame_buffer;
	uint16_t total_len = frame->mpdu[0] + 3; /* FCS in frame len, LQI after FCS */
	
	/* Allocate buffer for received frame */
	rcv_frame_buffer = bmm_buffer_alloc(total_len);
	
	if (rcv_frame_buffer != NULL) {
		/* copy data from incomming to outcomming buffer */
		memcpy(rcv_frame_buffer->body,frame->mpdu,total_len);
		/* and put them to USB output queue */
		qmm_queue_append(&qfWPANtUSB, rcv_frame_buffer);
	}
	
	// Free-up the buffer which was used for reception once the frame is extracted.
	bmm_buffer_free(frame->buffer_header);
}

bool prcm_device_enable(void)
{
	qmm_queue_init(&qfWPANtUSB);
	
	init_default_pib();

	return true;
}

void prcm_device_disable(void)
{
	buffer_t *tmp;

	/* purge all queues */
	while((tmp = qmm_queue_remove(&qfWPANtUSB, NULL)) != NULL)
		bmm_buffer_free(tmp);
}

/************************************************/
/* callback functions for device setup requests */
/************************************************/

static uint8_t dummy_write;
void start_callback(void);
void stop_callback(void);

void start_callback(void) {
	/*RX_AACK_ON Mode is enabled if Promiscuous Mode is not used,else RX is switched on in RX_ON Mode*/
	while(tal_rx_enable(PHY_RX_ON) != RX_ON);
	udi_vendor_bulk_out_run(usb_out_buff, sizeof(usb_out_buff),&prcm_usb_data_received);
	wdev->wpan_active = true;
}

void stop_callback(void) {
	/*Disable WPAN transfers*/
	set_trx_state(CMD_TRX_OFF);
	wdev->wpan_active = false;
}

static uint8_t channel_data;
void set_channel_callback(void);

void set_channel_callback(void) {
	wdev->channel = channel_data;
	tal_pib_set(phyCurrentChannel, (pib_value_t *)&wdev->channel);
}

static uint8_t page_data;
void set_page_callback(void);

void set_page_callback(void) {
	wdev->page = page_data;
	tal_pib_set(phyCurrentPage, (pib_value_t *)&wdev->page);
}

static uint64_t ieee_addr;
void ieee_address_callback(void);

void ieee_address_callback(void) {
	wdev->ieee_addr = ieee_addr;
	tal_pib_set(macIeeeAddress, (pib_value_t *)&wdev->ieee_addr);
}

static bool pan_coord;
void pancoord_callback(void);

void pancoord_callback(void)
{
	wdev->pan_coordinator = pan_coord;
	tal_pib_set(mac_i_pan_coordinator, (pib_value_t *)&wdev->pan_coordinator);
}

static uint16_t pan_id;
void panid_callback(void);

void panid_callback(void)
{
	wdev->pan_id = pan_id;
	tal_pib_set(macPANId, (pib_value_t *)&wdev->pan_id);
}

static uint16_t short_addr;
void short_address_callback(void);

void short_address_callback(void)
{
	wdev->short_addr = short_addr;
	tal_pib_set(macPANId, (pib_value_t *)&wdev->short_addr);
}

static uint8_t tx_power;
void tx_power_callback(void);

void tx_power_callback(void) {
	wdev->tx_power = tx_power;
	tal_pib_set(phyTransmitPower, (pib_value_t *)&wdev->tx_power);
}

static uint8_t lbt_mode;
void lbt_callback(void);

void lbt_callback(void) {
	wdev->lbt_mode = lbt_mode ? true : false;
	trx_bit_write(SR_CSMA_LBT_MODE, wdev->lbt_mode ? 1 : 0);
}

static uint8_t cca_mode;
void cca_callback(void);

void cca_callback(void) {
	wdev->cca_mode = cca_mode;
	tal_pib_set(phyCCAMode, (pib_value_t *)&wdev->cca_mode);
}

static uint8_t cca_ed_level;
void cca_ed_level_callback(void);

void cca_ed_level_callback(void) {
	wdev->cca_ed_level = cca_ed_level;
#ifdef CCA_ED_THRESHOLD
	trx_bit_write(SR_CCA_ED_THRES, wdev->cca_ed_level);
#endif // CCA_ED_THRESHOLD
}

static uint8_t csma_min_be;
void csma_min_be_callback(void);

void csma_min_be_callback(void) {
	wdev->csma_min_be = csma_min_be;
	tal_pib_set(macMinBE, (pib_value_t *)&wdev->csma_min_be);
}

static uint8_t csma_max_be;
void csma_max_be_callback(void);

void csma_max_be_callback(void) {
	wdev->csma_max_be = csma_max_be;
	tal_pib_set(macMinBE, (pib_value_t *)&wdev->csma_max_be);
}

static uint8_t csma_retries;
void csma_retries_callback(void);

void csma_retries_callback(void) {
	wdev->csma_retries = csma_retries;
	tal_pib_set(macMaxCSMABackoffs, (pib_value_t *)&wdev->csma_retries);
}

static uint8_t frame_retries;
void frame_retries_callback(void);

void frame_retries_callback(void) {
	wdev->max_frame_retries = frame_retries;
	tal_pib_set(macMaxFrameRetries, (pib_value_t *)&wdev->max_frame_retries);
}

#ifdef PROMISCUOUS_MODE
static uint8_t promisc_mode;
void promisc_mode_callback(void);

void promisc_mode_callback(void) {
	wdev->promisc_mode = promisc_mode ? true : false;
	tal_pib_set(macPromiscuousMode, (pib_value_t *)&wdev->promisc_mode);
}
#endif

#define SETUP_OUT_CALLBACK(structure, function) \
	{ \
		udd_g_ctrlreq.payload = (uint8_t *)&structure; \
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength; \
		udd_g_ctrlreq.callback = &function; \
		ret = true; \
	}

bool prcm_setup_out(void)
{
	bool ret = false;
	
	switch(udd_g_ctrlreq.req.wValue) {
		case REQ_WPAN_START:
			if (udd_g_ctrlreq.req.wLength == sizeof(dummy_write))
				SETUP_OUT_CALLBACK(dummy_write, start_callback);
			break;
		case REQ_WPAN_STOP:
			if (udd_g_ctrlreq.req.wLength == sizeof(dummy_write))
				SETUP_OUT_CALLBACK(dummy_write, stop_callback);
			break;
		case REQ_WPAN_SET_CHANNEL:
			if (udd_g_ctrlreq.req.wLength == sizeof(channel_data))
				SETUP_OUT_CALLBACK(channel_data, set_channel_callback);
			break;
		case REQ_WPAN_SET_PAGE:
			if (udd_g_ctrlreq.req.wLength == sizeof(page_data))
				SETUP_OUT_CALLBACK(page_data, set_page_callback);
			break;
		case REQ_WPAN_SET_SHORT_ADDR:
			if (udd_g_ctrlreq.req.wLength == sizeof(short_addr))
				SETUP_OUT_CALLBACK(short_addr, short_address_callback);
			break;
		case REQ_WPAN_SET_PAN_ID:
			if (udd_g_ctrlreq.req.wLength == sizeof(pan_id))
				SETUP_OUT_CALLBACK(pan_id, panid_callback);
			break;
		case REQ_WPAN_SET_HW_ADDR:
			if (udd_g_ctrlreq.req.wLength == sizeof(ieee_addr))
				SETUP_OUT_CALLBACK(ieee_addr, ieee_address_callback);
			break;
		case REQ_WPAN_SET_PAN_COORD:
			if (udd_g_ctrlreq.req.wLength == sizeof(pan_coord))
				SETUP_OUT_CALLBACK(ieee_addr, pancoord_callback);
		break;
		case REQ_WPAN_SET_TXPOWER:
			if (udd_g_ctrlreq.req.wLength == sizeof(tx_power))
				SETUP_OUT_CALLBACK(tx_power, tx_power_callback);
			break;
		case REQ_WPAN_SET_LBT:
			if (udd_g_ctrlreq.req.wLength == sizeof(lbt_mode))
				SETUP_OUT_CALLBACK(lbt_mode, lbt_callback);
			break;
		case REQ_WPAN_SET_CCA_MODE:
			if (udd_g_ctrlreq.req.wLength == sizeof(cca_mode))
				SETUP_OUT_CALLBACK(cca_mode, cca_callback);
			break;
		case REQ_WPAN_SET_CCA_ED_LEVEL:
			if (udd_g_ctrlreq.req.wLength == sizeof(cca_ed_level))
				SETUP_OUT_CALLBACK(cca_ed_level, cca_ed_level_callback);
			break;
		case REQ_WPAN_SET_CSMA_MIN_BE:
			if (udd_g_ctrlreq.req.wLength == sizeof(csma_min_be))
				SETUP_OUT_CALLBACK(csma_min_be, csma_min_be_callback);
			break;
		case REQ_WPAN_SET_CSMA_MAX_BE:
			if (udd_g_ctrlreq.req.wLength == sizeof(csma_max_be))
				SETUP_OUT_CALLBACK(csma_max_be, csma_max_be_callback);
			break;
		case REQ_WPAN_SET_CSMA_RETRIES:
			if (udd_g_ctrlreq.req.wLength == sizeof(csma_retries))
				SETUP_OUT_CALLBACK(csma_retries, csma_retries_callback);
			break;
		case REQ_WPAN_SET_FRAME_RETRIES:
			if (udd_g_ctrlreq.req.wLength == sizeof(frame_retries))
				SETUP_OUT_CALLBACK(frame_retries, frame_retries_callback);
			break;
#ifdef PROMISCUOUS_MODE
		case REQ_WPAN_SET_PROMISC_MODE:
			if (udd_g_ctrlreq.req.wLength == sizeof(promisc_mode))
				SETUP_OUT_CALLBACK(promisc_mode, promisc_mode_callback);
			break;
#endif
	}
	
	return ret;
}

bool prcm_setup_in(void)
{
	bool ret = false;
	
	switch(udd_g_ctrlreq.req.wValue) {
		case REQ_WPAN_GET_ED:
			udd_g_ctrlreq.payload = &wdev->last_ed;
			udd_g_ctrlreq.payload_size = sizeof(wdev->last_ed);
			ret = true;
			break;
		case REQ_WPAN_GET_FEATURES:
			udd_g_ctrlreq.payload = (uint8_t *)wdev;
			udd_g_ctrlreq.payload_size = sizeof(wpan_dev_cfg);
			ret = true;
			break;
		case REQ_WPAN_GET_CHANNEL_LIST:
			udd_g_ctrlreq.payload = (uint8_t *)&channel_page_support;
			udd_g_ctrlreq.payload_size = sizeof(channel_page_support);
			ret = true;
			break;
	}
	
	return ret;
}
