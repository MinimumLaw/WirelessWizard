/**
 * \file main.c
 *
 * Created: 25.02.2015 12:56:53
 * Author: alex
 *
 * \brief  Main file of Wireless Project generated by Project Wizard
 *
 * Copyright (c) 2014 Atmel Corporation. All rights reserved.
 *
 * \asf_license_start
 *
 * \page License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name of Atmel may not be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * 4. This software may only be redistributed and used in connection with an
 *    Atmel microcontroller product.
 *
 * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \asf_license_stop
 */

/**
 * \page license License
 * Copyright(c) 2014, Atmel Corporation All rights reserved.
 *
 * Licensed under Atmel's Limited License Agreement --> EULA.txt
 */

/* === INCLUDES ============================================================ */

#include "tal.h"
#include "wireless_api.h"

#include <tal_internal.h>
#include <tal_pib.h>

/* === PROTOTYPES ====================================================== */

/**
 * \brief Application task
 */
static void app_task(void);

void prcm_usb_data_received(udd_ep_status_t status,
	iram_size_t nb_transfered, udd_ep_id_t ep);


/* === IMPLEMENTATION ====================================================== */

/**
 * \brief Main function of the application
 */
int main(void)
{	
	/* Initialize the Wireless Module */
	wireless_init();    
	
	/*The Modules selected in the wizard are initialized here */
	modules_init();

	udc_attach(); /* attach to USB bus at end of initialization */

	while (1)
	{
		/* These methods are called to perform the default tasks of the MAC Stack */
		pal_task();
		tal_task();
		/* Custom (User) tasks are performed here. */
		app_task();
	}
}

queue_t	qfUSBtWPAN,qfWPANtUSB;

/**
 * \brief Application task
 */
uint8_t receive_psdu[128 + 1];
 void app_task(void)
{
	buffer_t *usb_to_wpan;
	buffer_t *wpan_to_usb;
	
	usb_to_wpan = qmm_queue_remove(&qfUSBtWPAN, NULL);
	if(usb_to_wpan != NULL) {
		frame_info_t *frame;
		
		frame = malloc(sizeof(frame_info_t));
		
		if(frame != NULL) {
			frame->mpdu = usb_to_wpan->body;
			frame->buffer_header = usb_to_wpan;
			if (wdev->wpan_active) /* connected and stated */
				tal_tx_frame(frame, wdev->csma_mode,
						wdev->max_frame_retries == 0 ? false : true);
			else { /* device connected, but _NOT_ started */
				free(frame);
				bmm_buffer_free(usb_to_wpan);
			}
		} else {
			/* TODO handle no memory for RX frame */
			/* This time - simple drop data buffer */
			bmm_buffer_free(usb_to_wpan);
		}
	}
	
	wpan_to_usb = qmm_queue_remove(&qfWPANtUSB, NULL);
	if(wpan_to_usb != NULL) {
		uint8_t usb_msg_size = wpan_to_usb->body[0] + 3; /* Frame + LQI */
		
		memcpy(receive_psdu, wpan_to_usb->body, usb_msg_size);
		if (wdev->wpan_active) /* only if host ready for data */
			/* TODO: This time _NOT_ handle error on USB data send to host */
			udi_vendor_bulk_in_run(receive_psdu, usb_msg_size, NULL);
		bmm_buffer_free(wpan_to_usb);
	}
}

/**
 *
 * \brief This method (callback) is called when a frame has been transmitted by the transceiver
 * \param status  Status of frame transmission i.e MAC_SUCCESS,MAC_NO_ACK,CHANNEL_ACCESS_FAILURE etc
 * \param frame pointer to the transmitted frame
 */
void tal_tx_frame_done_cb(retval_t status, frame_info_t *frame)
{
	/*Perform application tasks when a frame is transmitted here*/
	
	// Free-up the buffer which was used for transmission once the frame is extracted.
	bmm_buffer_free(frame->buffer_header);
	// Free-up allocated frame_info_t* structure
	free(frame);
}

/**
 *
 * \brief This method (callback) is called when a frame is received by the transceiver
 * \param frame pointer to the received frame
 *
 */
void tal_rx_frame_cb(frame_info_t *frame)
{
	buffer_t *rcv_frame_buffer;
	uint16_t total_len = frame->mpdu[0] + 3; /* FCS in frame len, LQI after FCS */
	
	/* Allocate buffer for received frame */
	rcv_frame_buffer = bmm_buffer_alloc(total_len);
	
	if (rcv_frame_buffer != NULL) {
		/* copy data from incomming to outcomming buffer */
		memcpy(rcv_frame_buffer->body,frame->mpdu,total_len);
		/* and put them to USB output queue */
		qmm_queue_append(&qfWPANtUSB, rcv_frame_buffer);
	}
	
	// Free-up the buffer which was used for reception once the frame is extracted.
	bmm_buffer_free(frame->buffer_header);
}

uint8_t usb_out_buff[128];
void prcm_usb_data_received(udd_ep_status_t status,
				iram_size_t nb_transfered, udd_ep_id_t ep)
{
	buffer_t *bmm_buff;
	
	if (status == UDD_EP_TRANSFER_OK) {
		uint8_t msg_size = usb_out_buff[0];
		bmm_buff = bmm_buffer_alloc(msg_size);
		if(bmm_buff != NULL) {
			memcpy(bmm_buff->body,usb_out_buff, nb_transfered); // FCS not received from host, but counted in length
			qmm_queue_append(&qfUSBtWPAN, bmm_buff);
		} else {
			/* TODO (IN PROCESS) Handle no memory for USB input buffer */
			/* Send NAK: Say: "Host sorry, data received but not handled now. Try again later" */
			udd_ep_abort(ep);
		}
	} else {
		/* TODO handle usb input fail transfer */
		/* This time - ignore and restart transfer */
	}
	/* restart transfer */
	udi_vendor_bulk_out_run(usb_out_buff, sizeof(usb_out_buff),&prcm_usb_data_received);
}

bool prcm_device_enable(void)
{
	qmm_queue_init(&qfUSBtWPAN);
	qmm_queue_init(&qfWPANtUSB);
	
	init_default_pib();

	udi_vendor_bulk_out_run(usb_out_buff, sizeof(usb_out_buff),&prcm_usb_data_received);
	return true;
}

void prcm_device_disable(void)
{
	buffer_t *tmp;

	/* purge all queues */
	while((tmp = qmm_queue_remove(&qfUSBtWPAN, NULL)) != NULL)
		bmm_buffer_free(tmp);
	while((tmp = qmm_queue_remove(&qfWPANtUSB, NULL)) != NULL)
		bmm_buffer_free(tmp);
}

/************************************************/
/* callback functions for device setup requests */
/************************************************/

static struct wpan_dummy_write dummy_write;
void start_callback(void);
void stop_callback(void);

void start_callback(void) {
	/*RX_AACK_ON Mode is enabled if Promiscuous Mode is not used,else RX is switched on in RX_ON Mode*/
	while(tal_rx_enable(PHY_RX_ON) != RX_ON);
	wdev->wpan_active = true;
}

void stop_callback(void) {
	/*Disable WPAN transfers*/
	set_trx_state(CMD_TRX_OFF);
	wdev->wpan_active = false;
}

static struct wpan_channel_data channel_data;
void set_channel_callback(void);

void set_channel_callback(void) {
	/* TODO linux-wireleess at this moment not set page, only channel. Need fixing */
//	wdev->page = channel_data.page;
//	wdev->channel = channel_data.channel;
	tal_pib_set(phyCurrentPage, (pib_value_t *)&wdev->page);
	tal_pib_set(phyCurrentChannel, (pib_value_t *)&wdev->channel);
}

static struct wpan_hw_addr_filt hw_filter;
void hw_filter_callback(void);

void hw_filter_callback(void) {
	/* check all known flags */
	if (hw_filter.changed & IEEE802515_AFILT_IEEEADDR_CHANGED) {
		wdev->ieee_addr = hw_filter.ieee_addr;
		tal_pib_set(macIeeeAddress, (pib_value_t *)&wdev->ieee_addr);
	};
	if (hw_filter.changed & IEEE802515_AFILT_PANC_CHANGED) {
		wdev->pan_coordinator = hw_filter.pan_coordinator ? true : false;
		tal_pib_set(mac_i_pan_coordinator,(pib_value_t *) &wdev->pan_coordinator);
	};
	if (hw_filter.changed & IEEE802515_AFILT_PANID_CHANGED) {
		wdev->pan_id = hw_filter.pan_id;
		tal_pib_set(macPANId, (pib_value_t *)&wdev->pan_id);
	};
	if (hw_filter.changed & IEEE802515_AFILT_SADDR_CHANGED) {
		wdev->short_addr = hw_filter.short_addr;
		tal_pib_set(macShortAddress, (pib_value_t *)&wdev->short_addr);
	};
	/* clear all checked flags */
	hw_filter.changed &= ~(IEEE802515_AFILT_IEEEADDR_CHANGED |
		IEEE802515_AFILT_PANC_CHANGED |	IEEE802515_AFILT_PANID_CHANGED |
		IEEE802515_AFILT_SADDR_CHANGED);
}

static uint64_t ieee_addr;
void ieee_address_callback(void);

void ieee_address_callback(void) {
	wdev->ieee_addr = ieee_addr;
	tal_pib_set(macIeeeAddress, (pib_value_t *)&wdev->ieee_addr);
}

static struct wpan_tx_power tx_power;
void tx_power_callback(void);

void tx_power_callback(void) {
	/* TODO linux-wireleess at this moment set tx-power to 0dBm, need fixing */
//	wdev->tx_power = tx_power.tx_power;
	tal_pib_set(phyTransmitPower, (pib_value_t *)&wdev->tx_power);
}

static struct wpan_lbt lbt;
void lbt_callback(void);

void lbt_callback(void) {
	wdev->lbt_mode = lbt.mode ? true : false;
	trx_bit_write(SR_CSMA_LBT_MODE, wdev->lbt_mode ? 1 : 0);
}

static struct wpan_cca cca;
void cca_callback(void);

void cca_callback(void) {
	wdev->cca_mode = cca.mode;
	tal_pib_set(phyCCAMode, (pib_value_t *)&wdev->cca_mode);
}

static struct wpan_cca_threshold cca_ed_level;
void cca_ed_level_callback(void);

void cca_ed_level_callback(void) {
	wdev->cca_ed_level = cca_ed_level.level;
#ifdef CCA_ED_THRESHOLD
	trx_bit_write(SR_CCA_ED_THRES, wdev->cca_ed_level);
#endif // CCA_ED_THRESHOLD
}

static struct wpan_csma_params csma;
void csma_callback(void);

void csma_callback(void) {
	wdev->csma_min_be = csma.min_be;
	wdev->csma_max_be = csma.max_be;
	wdev->csma_retries = csma.retries;
	tal_pib_set(macMinBE, (pib_value_t *)&wdev->csma_min_be);
	tal_pib_set(macMaxBE, (pib_value_t *)&wdev->csma_max_be);
	tal_pib_set(macMaxCSMABackoffs, (pib_value_t *)&wdev->csma_retries);
}

static struct wpan_frame_retries frame_retries;
void frame_retries_callback(void);

void frame_retries_callback(void) {
	wdev->max_frame_retries = frame_retries.count;
	tal_pib_set(macMaxFrameRetries, (pib_value_t *)&wdev->max_frame_retries);
}


#define SETUP_OUT_CALLBACK(structure, function) \
	{ \
		udd_g_ctrlreq.payload = (uint8_t *)&structure; \
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength; \
		udd_g_ctrlreq.callback = &function; \
		ret = true; \
	}

bool prcm_setup_out(void)
{
	bool ret = false;
	
	switch(udd_g_ctrlreq.req.wValue) {
		case REQ_WPAN_START:
			if (udd_g_ctrlreq.req.wLength == sizeof(struct wpan_dummy_write))
				SETUP_OUT_CALLBACK(dummy_write, start_callback);
			break;
		case REQ_WPAN_STOP:
			if (udd_g_ctrlreq.req.wLength == sizeof(struct wpan_dummy_write))
				SETUP_OUT_CALLBACK(dummy_write, stop_callback);
			break;
		case REQ_WPAN_SET_CHANNEL:
			if (udd_g_ctrlreq.req.wLength == sizeof(struct wpan_channel_data))
				SETUP_OUT_CALLBACK(channel_data, set_channel_callback);
			break;
		case REQ_WPAN_SET_HWADDR_FILT:
			if (udd_g_ctrlreq.req.wLength == sizeof(struct wpan_hw_addr_filt))
				SETUP_OUT_CALLBACK(hw_filter, hw_filter_callback);
			break;
		case REQ_WPAN_SET_HWADDR:
			if (udd_g_ctrlreq.req.wLength == sizeof(ieee_addr))
				SETUP_OUT_CALLBACK(ieee_addr, ieee_address_callback);
			break;
		case REQ_WPAN_SET_TXPOWER:
			if (udd_g_ctrlreq.req.wLength == sizeof(tx_power))
				SETUP_OUT_CALLBACK(tx_power, tx_power_callback);
			break;
		case REQ_WPAN_SET_LBT:
			if (udd_g_ctrlreq.req.wLength == sizeof(lbt))
				SETUP_OUT_CALLBACK(lbt, lbt_callback);
			break;
		case REQ_WPAN_SET_CCA_MODE:
			if (udd_g_ctrlreq.req.wLength == sizeof(cca))
				SETUP_OUT_CALLBACK(cca, cca_callback);
			break;
		case REQ_WPAN_SET_CCA_ED_LEVEL:
			if (udd_g_ctrlreq.req.wLength == sizeof(cca_ed_level))
				SETUP_OUT_CALLBACK(cca_ed_level, cca_ed_level_callback);
		break;
		case REQ_WPAN_SET_CSMA_PARAMS:
			if (udd_g_ctrlreq.req.wLength == sizeof(csma))
				SETUP_OUT_CALLBACK(csma, csma_callback);
			break;
		case REQ_WPAN_SET_FRAME_RETRIES:
			if (udd_g_ctrlreq.req.wLength == sizeof(frame_retries))
				SETUP_OUT_CALLBACK(frame_retries, frame_retries_callback);
			break;
	}
	
	return ret;
}

bool prcm_setup_in(void)
{
	bool ret = false;
	
	switch(udd_g_ctrlreq.req.wValue) {
		case REQ_WPAN_GET_ED:
			udd_g_ctrlreq.payload = &wdev->last_ed;
			udd_g_ctrlreq.payload_size = sizeof(wdev->last_ed);
			ret = true;
			break;
		case REQ_WPAN_GET_FEATURES:
			udd_g_ctrlreq.payload = (uint8_t *)wdev;
			udd_g_ctrlreq.payload_size = sizeof(wpan_dev_cfg);
			ret = true;
			break;
		case REQ_WPAN_GET_CHANNEL_LIST:
			udd_g_ctrlreq.payload = (uint8_t *)&channel_page_support;
			udd_g_ctrlreq.payload_size = sizeof(channel_page_support);
			ret = true;
			break;
	}
	
	return ret;
}
